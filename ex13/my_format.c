//avichay ben lulu 301088670
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <math.h>
#include <time.h>
#include <linux/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include "fat12.h"

#define BYTE 8
#define SECTORS_PER_CLUSTER 1
#define SECTOR_SIZE 512
#define RESERVED_SECTOR_COUNT 1
#define NUMBER_OF_FATS 2
#define NUMBER_OF_DIRENTS 224
#define SECTOR_COUNT 2880
#define MEDIA_TYPE 0xf0
#define FAT_SIZE_SECTORS 9
#define SECTORS_PER_TRACK 18
#define NHEADS 2
#define SECTORS_HIDDEN 0
#define SECTOR_COUNT_LARGE 0
#define FAT1 9
#define FAT2 18
#define DATA_AREA 32

int fid; /* global variable set by the open() function */


int fd_read(int sector_number, char *buffer)
{
	int dest, len;
	int bps=SECTOR_SIZE;
	dest = lseek(fid, sector_number * DEFAULT_SECTOR_SIZE, SEEK_SET);
	if (dest != sector_number * bps){
		// Error handling
		printf("\nERROR: in fd_read");
	}
	len = read(fid, buffer, bps);
	if (len != bps){
		// error handling here
		printf("\nERROR:  in fd_read");
	}
	return len;
}

int fd_write(int sector_number, char *buffer)
{
	int dest, len;
	int bps=SECTOR_SIZE;
	dest = lseek(fid, sector_number * DEFAULT_SECTOR_SIZE, SEEK_SET);
	if (dest != sector_number * bps){
		// Error handling
		printf("\nERROR: in fd_write");
	}
	len = write(fid, buffer, bps);
	if (len != bps){
		 //error handling here
		printf("\nERROR in fd_write");
	}
	return len;
}
int main(int argc, char *argv[])
{

	if (argc != 2)
	{
		printf("Usage: %s <floppy_image>\n", argv[0]);
		exit(1);
	}

	if ( (fid = open (argv[1], O_RDWR|O_CREAT, 0644))  < 0 )
	{
		perror("Error: ");
		return -1;
	}

	

	//step 1 -initialize boot sector
	boot_record_t boot;
	for(int i=0;i<BYTE;i++)
		boot.oem_id[i]=0;

	boot.sector_size=SECTOR_SIZE;
	boot.sectors_per_cluster=SECTORS_PER_CLUSTER;
	boot.reserved_sector_count=RESERVED_SECTOR_COUNT;
	boot.number_of_fats=NUMBER_OF_FATS;
	boot.number_of_dirents=NUMBER_OF_DIRENTS;
	boot.sector_count=SECTOR_COUNT;
	boot.media_type=MEDIA_TYPE;
	boot.fat_size_sectors=FAT_SIZE_SECTORS;
	boot.sectors_per_track=SECTORS_PER_TRACK;
	boot.nheads=NHEADS;
	boot.sectors_hidden=SECTORS_HIDDEN;
	boot.sector_count_large=SECTOR_COUNT_LARGE;

	if (read(fid, &boot, sizeof (boot)) > 0)
    {
		printf("sector_size: %d\n", boot.sector_size);
    	printf("sectors_per_cluster: %d\n", boot.sectors_per_cluster);
    	printf("reserved_sector_count: %d\n", boot.reserved_sector_count);
    	printf("number_of_fats: %d\n", boot.number_of_fats);
    	printf("number_of_dirents: %d\n", boot.number_of_dirents);
        printf("sector_count: %d\n", boot.sector_count);
	}
	
	// Step 2. Set FAT1/FAT2 table entires to 0x0000 (unused cluster)
    // according to the fat12.pdf.
	char buf[SECTOR_SIZE]={0};
	memcpy(buf,&boot,sizeof(boot));
	fd_write(0,buf);
	char bufReserved[SECTOR_SIZE]={0};
	bufReserved[0]=0xFF;
	bufReserved[1]=0x0F;
	bufReserved[2]=0xF8;
	char bufZero[SECTOR_SIZE]={0};
	fd_write(1,bufReserved); //fat 1 first entry in first sector - reserved
	for(int i=2;i< FAT1;i++)	//zeroing rest of fat 2	(unclusterd)
		fd_write(i,bufZero);
	fd_write(10,bufReserved);//fat 2 first entry in first sector - reserved
	for(int i=FAT1+1;i< FAT2;i++)	//fat 2 unclusterd
		fd_write(i,bufZero);

	// Step 3. Set direntries as free (0xe5) according to the fat12.pdf.
    // While zeroing dentries will also work, we prefer a solution
    // that mark them free. In that case it will be possible to perform
    // unformat operation. However, school solution simply zeros dentries.
	for(int i=FAT2+1;i<DATA_AREA;i++)
		fd_write(i,bufZero);
	// Step 4. Handle data block (e.g you can zero them or just leave 
	// untouched. What are the pros/cons?)
	for(int i=DATA_AREA + 1;i<SECTOR_COUNT;i++)
		fd_write(i,bufZero);
	// For steps 2-3, you can also read the sectors from the image that was 
	// generated by the school solution if not sure what should be the values.
	
	
	close(fid);
	return 0;
}

